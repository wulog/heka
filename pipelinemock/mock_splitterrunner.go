// Automatically generated by MockGen. DO NOT EDIT!
// Source: heka/pipeline (interfaces: SplitterRunner)

package pipelinemock

import (
	gomock "github.com/rafrombrc/gomock/gomock"
	pipeline "heka/pipeline"
	io "io"
)

// Mock of SplitterRunner interface
type MockSplitterRunner struct {
	ctrl     *gomock.Controller
	recorder *_MockSplitterRunnerRecorder
}

// Recorder for MockSplitterRunner (not exported)
type _MockSplitterRunnerRecorder struct {
	mock *MockSplitterRunner
}

func NewMockSplitterRunner(ctrl *gomock.Controller) *MockSplitterRunner {
	mock := &MockSplitterRunner{ctrl: ctrl}
	mock.recorder = &_MockSplitterRunnerRecorder{mock}
	return mock
}

func (_m *MockSplitterRunner) EXPECT() *_MockSplitterRunnerRecorder {
	return _m.recorder
}

func (_m *MockSplitterRunner) DeliverRecord(_param0 []byte, _param1 pipeline.Deliverer) {
	_m.ctrl.Call(_m, "DeliverRecord", _param0, _param1)
}

func (_mr *_MockSplitterRunnerRecorder) DeliverRecord(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "DeliverRecord", arg0, arg1)
}

func (_m *MockSplitterRunner) Done() {
	_m.ctrl.Call(_m, "Done")
}

func (_mr *_MockSplitterRunnerRecorder) Done() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Done")
}

func (_m *MockSplitterRunner) GetRecordFromStream(_param0 io.Reader) (int, []byte, error) {
	ret := _m.ctrl.Call(_m, "GetRecordFromStream", _param0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].([]byte)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

func (_mr *_MockSplitterRunnerRecorder) GetRecordFromStream(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "GetRecordFromStream", arg0)
}

func (_m *MockSplitterRunner) GetRemainingData() []byte {
	ret := _m.ctrl.Call(_m, "GetRemainingData")
	ret0, _ := ret[0].([]byte)
	return ret0
}

func (_mr *_MockSplitterRunnerRecorder) GetRemainingData() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "GetRemainingData")
}

func (_m *MockSplitterRunner) IncompleteFinal() bool {
	ret := _m.ctrl.Call(_m, "IncompleteFinal")
	ret0, _ := ret[0].(bool)
	return ret0
}

func (_mr *_MockSplitterRunnerRecorder) IncompleteFinal() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "IncompleteFinal")
}

func (_m *MockSplitterRunner) IsStoppable() bool {
	ret := _m.ctrl.Call(_m, "IsStoppable")
	ret0, _ := ret[0].(bool)
	return ret0
}

func (_mr *_MockSplitterRunnerRecorder) IsStoppable() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "IsStoppable")
}

func (_m *MockSplitterRunner) KeepTruncated() bool {
	ret := _m.ctrl.Call(_m, "KeepTruncated")
	ret0, _ := ret[0].(bool)
	return ret0
}

func (_mr *_MockSplitterRunnerRecorder) KeepTruncated() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "KeepTruncated")
}

func (_m *MockSplitterRunner) LeakCount() int {
	ret := _m.ctrl.Call(_m, "LeakCount")
	ret0, _ := ret[0].(int)
	return ret0
}

func (_mr *_MockSplitterRunnerRecorder) LeakCount() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "LeakCount")
}

func (_m *MockSplitterRunner) LogError(_param0 error) {
	_m.ctrl.Call(_m, "LogError", _param0)
}

func (_mr *_MockSplitterRunnerRecorder) LogError(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "LogError", arg0)
}

func (_m *MockSplitterRunner) LogMessage(_param0 string) {
	_m.ctrl.Call(_m, "LogMessage", _param0)
}

func (_mr *_MockSplitterRunnerRecorder) LogMessage(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "LogMessage", arg0)
}

func (_m *MockSplitterRunner) Name() string {
	ret := _m.ctrl.Call(_m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

func (_mr *_MockSplitterRunnerRecorder) Name() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Name")
}

func (_m *MockSplitterRunner) Plugin() pipeline.Plugin {
	ret := _m.ctrl.Call(_m, "Plugin")
	ret0, _ := ret[0].(pipeline.Plugin)
	return ret0
}

func (_mr *_MockSplitterRunnerRecorder) Plugin() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Plugin")
}

func (_m *MockSplitterRunner) SetInputRunner(_param0 pipeline.InputRunner) {
	_m.ctrl.Call(_m, "SetInputRunner", _param0)
}

func (_mr *_MockSplitterRunnerRecorder) SetInputRunner(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "SetInputRunner", arg0)
}

func (_m *MockSplitterRunner) SetLeakCount(_param0 int) {
	_m.ctrl.Call(_m, "SetLeakCount", _param0)
}

func (_mr *_MockSplitterRunnerRecorder) SetLeakCount(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "SetLeakCount", arg0)
}

func (_m *MockSplitterRunner) SetName(_param0 string) {
	_m.ctrl.Call(_m, "SetName", _param0)
}

func (_mr *_MockSplitterRunnerRecorder) SetName(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "SetName", arg0)
}

func (_m *MockSplitterRunner) SetPackDecorator(_param0 func(*pipeline.PipelinePack)) {
	_m.ctrl.Call(_m, "SetPackDecorator", _param0)
}

func (_mr *_MockSplitterRunnerRecorder) SetPackDecorator(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "SetPackDecorator", arg0)
}

func (_m *MockSplitterRunner) SplitBytes(_param0 []byte, _param1 pipeline.Deliverer) (int, error) {
	ret := _m.ctrl.Call(_m, "SplitBytes", _param0, _param1)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockSplitterRunnerRecorder) SplitBytes(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "SplitBytes", arg0, arg1)
}

func (_m *MockSplitterRunner) SplitStream(_param0 io.Reader, _param1 pipeline.Deliverer) error {
	ret := _m.ctrl.Call(_m, "SplitStream", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockSplitterRunnerRecorder) SplitStream(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "SplitStream", arg0, arg1)
}

func (_m *MockSplitterRunner) SplitStreamNullSplitterToEOF(_param0 io.Reader, _param1 pipeline.Deliverer) error {
	ret := _m.ctrl.Call(_m, "SplitStreamNullSplitterToEOF", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockSplitterRunnerRecorder) SplitStreamNullSplitterToEOF(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "SplitStreamNullSplitterToEOF", arg0, arg1)
}

func (_m *MockSplitterRunner) Splitter() pipeline.Splitter {
	ret := _m.ctrl.Call(_m, "Splitter")
	ret0, _ := ret[0].(pipeline.Splitter)
	return ret0
}

func (_mr *_MockSplitterRunnerRecorder) Splitter() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Splitter")
}

func (_m *MockSplitterRunner) Unregister(_param0 *pipeline.PipelineConfig) error {
	ret := _m.ctrl.Call(_m, "Unregister", _param0)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockSplitterRunnerRecorder) Unregister(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Unregister", arg0)
}

func (_m *MockSplitterRunner) UseMsgBytes() bool {
	ret := _m.ctrl.Call(_m, "UseMsgBytes")
	ret0, _ := ret[0].(bool)
	return ret0
}

func (_mr *_MockSplitterRunnerRecorder) UseMsgBytes() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "UseMsgBytes")
}
